# Promise
promise - future value
the later await for the promise, the better

Для того, чтобы промис вернул что-то (хотя бы результат своего выполнения), нужно три вещи:
     - зарезолвить его внутри колбэка его создания (этот колбэк синхронный),
что добавит его в список  settled (завершенных) промисов
     - добавить к нему обработчик с помощью then/catch/finally или await. Если промис уже settled,
то это сразу добавит обработчик в очередь микрозадач. Если нет - в специальный список
     - дождаться, пока выполнится текущий код и eventloop начнет выполнять микрозадачи
В очередь он добавляется ТОЛЬКО ТОГДА, КОГДА ОН SETTLED И ИМЕЕТ МИНИМУМ ОДИН ОБРАБОТЧИК. 

Промис работает вне основного выполнения, поэтому если в нём выпадет ошибка, которую мы не обработали,
то он продолжит висеть, а try/catch вокруг этого промиса в нашем коде не отловит ошибку. Для того, чтобы эту
ошибку он вернул, нужно вызвать reject. Тогда она будет выловлена внешним try/catch.

Состояния:
   - pending - только обрабатывается
   - fulfilled - отработал и может вернуть значение
   - rejected - отработал с ошибкой
   - SETTLED - отработал (не важно, как)


# Async/await

async/await - просто синтаксический сахар для промисов.

Когда мы помечаем ф-ю как async, то она выполняется асинхронно, т.е. она НЕ БЛОКАЕТ ВСЁ ПРИЛОЖЕНИЕ,
а работает в фоне. ReadfileSync будет фризить всё, пока не прочитает, а ReadFile будет работать сама по себе,
если мы не захотим подождать её await-ом.

Await заставляет js остановить выполнение синхронного кода текущей ф-и, пока не вернется ответ из промиса.
Когда мы будем её ждать, блокнется только текущая ф-я, а всё остальное будет работать.

Хорошая модель для представления работы await - await оборачивает оставшуюся часть кода ф-и в then и
добавляет этот then к промису, которого ожидает. То есть, делает то же, что и обычный then, но в более
читаемом виде ('**await p** schedules execution of the rest of your function when promise p resolves. That's all.')