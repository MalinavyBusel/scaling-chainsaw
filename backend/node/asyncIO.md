Есть операции, которые блокируют поток - он простаивает и просто ждёт чего-то, теряя процессорное время.
Среди них:
- чтение и запись в файл
- отправка и получение по сети
- резрешение dns имени

В ноде, чтобы такого не было, есть event loop. Когда начинается блокающая операция по сети, он не ждёт, пока она выполнится,
а работает дальше и потом возвращается к ней, когда получает сообщение о готовности. Для работы с dns-resolving
и файловым IO, так как эти операции по натуре синхронные, он выделяет их в пул потоков, а сам продолжает работу.

Поэтому, с одной стороны, нода single-threaded, тк синхронный код всегда выполняется только в одном потоке (один контекст исполнения). С другой,
есть thread pool, который обрабатывает IO штуки, и worker threads.

1. Для того, чтобы каждый раз не спрашивать про обновления в коннекшнах, в Linux используются операции select, poll, epoll, который
мониторит файловые дескрипторы каждого соединения и при изменении создает event.
У select и poll сложность линейная, у epoll - логарифм

2. Для других IO операций используется thread pool.
    - DNS resolver (since many operating systems only offer synchronous API for this purpose)
    - File system API (as it becomes complicated to handle asynchronously across different platforms)
    - Crypto (due to its utilization of the CPU)
    - Zlib (used for zip compression)