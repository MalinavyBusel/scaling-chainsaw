Реализован в libuv

Всякие fs, crypto и http, dns и тд говорят пулу потоков что-то сделать и уведомить eventloop, когда результат будет готов
Нода использует пул не для всех операций, а только для некоторых (для тех, у которых в системе нет асинхронного апи
и если их запустить, то eventloop блокнется)

Потоков в пуле 4 шт. То есть, если они все заняты, то придется ждать, пока один не оссвободится.
Кол-во потоков в пуле можно увеличить, поставив process.env.UV_THREADPOOL_SIZE на большее значение. Желательно
не ставить потоков больше, чем ядер в CPU, иначе будет тратится время не переключение между ними (они будут переключаться
на равные промежутки времени на каждый поток на ядре, поэтому выполнение в целом займет дольше) - к примеру:\
1 - 5с, 2 - 6с -> 1 - 2c, 2 - 2c, 1 - 2c, 2 - 2c, 1 - 1c, 2 - 2c.\
В таком случае время выполнения всех кроме последнего выполненного  увеличится (это работает для CPU intensive,
но немного отличается для network и fs, там нужно просто отследить когда появятся данные и сказать об этом ноде)

Если занять все потоки, то это может стать bottleneck-ом